# -*- coding: utf-8 -*-
"""StockPrediction!!!

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14z0f4WKjg_pA6-4rHzAYxmb7pZWbc79s
"""

#yahoo finance as data source
#pip install yfinance
import yfinance as yf

#See the yahoo finance ticker for your stock symbol
stock_symbol = 'GAIL.NS'

#last 5 years data with interval of 1 day
data = yf.download(tickers=stock_symbol,period='5y',interval='1d')

type(data)

data.head()

len(data)

data.tail()

opn = data[['Open']]

opn.plot()

import matplotlib.pyplot as plt

ds = opn.values

ds

plt.plot(ds)

import numpy as np

from sklearn.preprocessing import MinMaxScaler

#Using MinMaxScaler for normalizing data between 0 & 1
normalizer = MinMaxScaler(feature_range=(0,1))
ds_scaled = normalizer.fit_transform(np.array(ds).reshape(-1,1))

len(ds_scaled), len(ds)

#Defining test and train data sizes
train_size = int(len(ds_scaled)*0.70)
test_size = len(ds_scaled) - train_size

train_size,test_size

#Splitting data between train and test
ds_train, ds_test = ds_scaled[0:train_size,:], ds_scaled[train_size:len(ds_scaled),:1]

len(ds_train),len(ds_test)

#creating dataset in time series for LSTM model
#X[100,120,140,160,180] : Y[200]
def create_ds(dataset,step):
    Xtrain, Ytrain = [], []
    for i in range(len(dataset)-step-1):
        a = dataset[i:(i+step), 0]
        Xtrain.append(a)
        Ytrain.append(dataset[i + step, 0])
    return np.array(Xtrain), np.array(Ytrain)

#Taking 100 days price as one record for training
time_stamp = 100
X_train, y_train = create_ds(ds_train,time_stamp)
X_test, y_test = create_ds(ds_test,time_stamp)

X_train.shape,y_train.shape

X_test.shape, y_test.shape

#Reshaping data to fit into LSTM model
X_train = X_train.reshape(X_train.shape[0],X_train.shape[1] , 1)
X_test = X_test.reshape(X_test.shape[0],X_test.shape[1] , 1)

from keras.models import Sequential
from keras.layers import Dense, LSTM

#Creating LSTM model using keras
model = Sequential()
model.add(LSTM(units=50,return_sequences=True,input_shape=(X_train.shape[1],1)))
model.add(LSTM(units=50,return_sequences=True))
model.add(LSTM(units=50))
model.add(Dense(units=1,activation='linear'))
model.summary()

#Training model with adam optimizer and mean squared error loss function
model.compile(loss='mean_squared_error',optimizer='adam')
model.fit(X_train,y_train,validation_data=(X_test,y_test),epochs=100,batch_size=64)

#PLotting loss, it shows that loss has decreased significantly and model trained well
loss = model.history.history['loss']
plt.plot(loss)

#Predicitng on train and test data
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

train_pred = normalizer.inverse_transform(train_predict)
test_pred = normalizer.inverse_transform(test_predict)

import math
from sklearn.metrics import mean_squared_error
math.sqrt(mean_squared_error(y_train,train_predict))

math.sqrt(mean_squared_error(y_test,test_predict))
import numpy as np

look_back = 100
trainpredictplot = np.empty_like(ds_scaled)
trainpredictplot[:, :] = np.nan
trainpredictplot[look_back:len(train_predict)+ look_back, :] = train_predict

#shift test prediction for plotting
testpredictplot = np.empty_like(ds_scaled)
testpredictplot[:, :] = np.nan
testpredictplot[len(train_pred)+ (look_back*2)+1:len(ds_scaled)-1, :] = test_predict

#plot baseline and prediction
plt.plot(normalizer.inverse_transform(ds_scaled))
plt.plot(trainpredictplot)
plt.plot(testpredictplot)
plt.show()

len(ds_test)

fut_input = ds_test[271:].reshape(1,-1)
fut_input.shape

temp_input = list(fut_input)
temp_input = temp_input[0].tolist()

from numpy import array

#Predicting next 30 days price suing the current data
#It will predict in sliding window manner (algorithm) with stride 1
lst_output=[]
n_steps=100
i=0
while(i<30):

    if(len(temp_input)>100): # Check if you have enough input data for prediction
        fut_input = np.array(temp_input[1:]) # Create the future input by excluding the first element
        print("{} day input {}".format(i,fut_input))
        fut_input = fut_input.reshape(1,-1)  # Reshape the input data
        fut_input = fut_input.reshape((1, n_steps, 1))
        yhat = model.predict(fut_input, verbose=0) # Use the model to predict the next day
        print("{} day output {}".format(i,yhat))
        temp_input.extend(yhat[0].tolist())   # Add the predicted value to the input data
        temp_input = temp_input[1:]   # Remove the oldest data point from the input
        lst_output.extend(yhat.tolist())  # Add the prediction to the output list
        i=i+1
    else:
        fut_input = fut_input.reshape((1, n_steps,1))   # Reshape the input data for prediction
        yhat = model.predict(fut_input, verbose=0)     # Use the model to predict the next day
        print(yhat[0])
        temp_input.extend(yhat[0].tolist())   # Add the predicted value to the input data
        print(len(temp_input))
        lst_output.extend(yhat.tolist())    # Add the prediction to the output list
        i=i+1


print(lst_output)

len(ds_scaled)

#Creating a dummy plane to plot graph one after another
plot_new=np.arange(1,101)
plot_pred=np.arange(101,131)

# Plot the actual data for the next 100 days starting from index 1135 and inverse transform it
plt.plot(plot_new, normalizer.inverse_transform(ds_scaled[1135:]))
# Plot the predicted data for the next 30 days starting from day 101 (plot_pred) and inverse transform it
plt.plot(plot_pred, normalizer.inverse_transform(lst_output))

ds_new = ds_scaled.tolist()

#Entends helps us to fill the missing value with approx value
ds_new.extend(lst_output)
plt.plot(ds_new[1200:])

#Creating final data for plotting
final_graph = normalizer.inverse_transform(ds_new).tolist()

#Plotting final results with predicted value after 30 Days
plt.plot(final_graph,)  # Plot the final_graph data
plt.ylabel("Price")     # Set the y-axis label to "Price"
plt.xlabel("Time")      # Set the x-axis label to "Time"
plt.title("{0} prediction of next month open".format(stock_symbol))    # Set the plot title with the stock symbol
# Add a horizontal line at the last value of final_graph and label it
plt.axhline(y=final_graph[len(final_graph)-1], color = 'red', linestyle = ':', label = 'NEXT 30D: {0}'.format(round(float(*final_graph[len(final_graph)-1]),2)))
plt.legend()  # Show the legend with the label

#Hence we have successfully predict the stock price for next 30 days!

